# 第4节：String奇妙法（上）

Java字符串那些事儿 
我们再来看一段代码： 
 
运行一下： 
 
没错，一个true，一个是false，（答错的小朋友去面壁去），大家可能在想编译器肯定又调皮了，编译的时候是不是又偷偷加了些什么，迫不及待的打开class文件看一下： 
 
除了删掉了空行以外和我的java源文件一致呀，这回可冤枉编译器了，那为什么会导致不同的结果呢？我们都知道，Java代码是运行在JVM里的，那是不是JVM在执行这段代码时给我们做了什么？ 
在JVM中，当代码执行到`String s1 = "100"` 时，会先看常量池里有没有字符串刚好是“100”这个对象，如果没有，在常量池里创建初始化该对象，并把引用指向它，如下图，绿色部分为常量池，存在于堆内存中。 

当执行到`String s2 = "100" `时，发现常量池已经有了100这个值，于是不再在常量池中创建这个对象，而是把引用直接指向了该对象，如下图： 

这时候我们打印`System.out.println(s1 == s2)`时，由于==是判断两个对象是否指向同一个引用，所以这儿打印出来的就应该是true。 
继续执行到Strings3 = new String("100") 这时候我们加了一个new关键字，这个关键字呢就是告诉JVM，你直接在堆内存里给我开辟一块新的内存，如下图所示： 

继续执行`String s4 = new String("100")`

这时候再打印`System.out.println(s3 == s4)` 那一定便是false了，因为s3和s4不是指向对一个引用（对象）。 
注：图中只是画出了main方法栈和相关对象在内存中的大致模拟，实际中JVM中内存管理比较复杂，大家有条件的话可以去找《Java虚拟机规范》这本书去深入研究。 
结论：我们在比较两个String对象内容时，无论是怎么声明的，都一定要使用equals去比较，不能用==，在Java中没有重载操作符这一说，特别是从其它语言转到Java的童鞋们要注意。equals我在其它文章里已经做了详细解说，传送门：说说Java里的equals（上） - 知乎专栏 
